╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                        UMAP HNSW-RS ARCHITECTURE DIAGRAM                                                              ║
╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                        PYTHON USER API LAYER                                                          │
│                                                                                                                         │
│   umap.UMAP(metric='euclidean', ...)                                                                                 │
│   └─> umap.umap_.fit_transform(X)                                                                                    │
│       └─> nearest_neighbors(X, n_neighbors, metric, ...)                                                              │
│                                                                                                                         │
│   PARAMETER FLOW:                                                                                                     │
│   • use_pynndescent parameter → determines backend                                                                    │
│   • metric ('euclidean', 'cosine', etc.) → matched against hnsw_metrics                                              │
│   • sparse_data check → fallback to PyNNDescent if true                                                               │
│                                                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
                                                    │
                                                    │ _get_nn_backend(metric, sparse_data, use_hnsw=None)
                                                    │ Decides: HnswIndexWrapper vs NNDescent
                                                    ▼
┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                              PYTHON WRAPPER LAYER (hnsw_wrapper.py)                                                   │
│                                                                                                                         │
│   ┌─────────────────────────────────────────────────────────────┐                                                    │
│   │ HnswIndexWrapper (PyNNDescent-compatible API)               │                                                    │
│   ├─────────────────────────────────────────────────────────────┤                                                    │
│   │ __init__(data, n_neighbors, metric, ...)                   │                                                    │
│   │  • Converts PyNNDescent params → HNSW params               │                                                    │
│   │  • n_trees → m (8-64)                                       │                                                    │
│   │  • n_iters × max_candidates → ef_construction (200-800)    │                                                    │
│   │  • Ensures data is float32                                  │                                                    │
│   │  • Instantiates Rust _HnswIndex                             │                                                    │
│   ├─────────────────────────────────────────────────────────────┤                                                    │
│   │ Methods:                                                     │                                                    │
│   │  query(queries, k, epsilon) → (indices, distances)         │                                                    │
│   │   └─> Maps epsilon → ef parameter                          │                                                    │
│   │       Calls self._index.query(queries, k, ef)              │                                                    │
│   │                                                              │                                                    │
│   │  neighbor_graph() → (indices, distances) | None            │                                                    │
│   │   └─> Caches result on first call                          │                                                    │
│   │       Returns cached or computes via self._index            │                                                    │
│   │                                                              │                                                    │
│   │  prepare() → None (no-op for API compat)                   │                                                    │
│   │                                                              │                                                    │
│   │  update(X) → None                                           │                                                    │
│   │   └─> Extends data, calls self._index.update()             │                                                    │
│   │       Invalidates neighbor_graph_cache                      │                                                    │
│   └─────────────────────────────────────────────────────────────┘                                                    │
│                                                                                                                         │
│   Properties: neighbor_graph, _angular_trees, _raw_data                                                               │
│                                                                                                                         │
│   IMPORTS:                                                                                                            │
│   try: from _hnsw_backend import HnswIndex as _HnswIndex  # Direct binary import                                    │
│   except ImportError:                                                                                                 │
│       try: from umap._hnsw_backend import HnswIndex        # Fallback to site-packages                              │
│       except ImportError: _HnswIndex = None                 # Graceful degradation                                    │
│                                                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
                                                    │
                                                    │ PyO3 Foreign Function Interface (FFI)
                                                    │ _HnswIndex (Rust struct exposed via PyO3)
                                                    ▼
┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                              RUST IMPLEMENTATION LAYER (src/)                                                         │
│                                                                                                                         │
│   ┌────────────────────────────────────────────────────┐       ┌────────────────────────────────────────────────────┐
│   │ lib.rs (PyO3 Module Definition, 10 lines)           │       │ hnsw_index.rs (Core K-NN, 382 lines)             │
│   ├────────────────────────────────────────────────────┤       ├────────────────────────────────────────────────────┤
│   │ #[pymodule]                                        │       │ pub struct HnswIndex {                             │
│   │ fn _hnsw_backend(...) -> PyResult<()> {            │       │     data: Vec<Vec<f32>>,    // All points          │
│   │     m.add_class::<HnswIndex>()?;                   │       │     n_neighbors: usize,                            │
│   │     Ok(())                                         │       │     metric: String,                                │
│   │ }                                                  │       │     is_angular: bool,                              │
│   │                                                    │       │     neighbor_graph_cache: Option<...>,             │
│   │ Registers HnswIndex class for Python              │       │ }                                                  │
│   └────────────────────────────────────────────────────┘       │                                                    │
│                                                                 │ KEY METHODS:                                       │
│   ┌────────────────────────────────────────────────────┐       │                                                    │
│   │ metrics.rs (Distance Metrics, 171 lines)           │       │ 1. new(data, n_neighbors, metric, m, ef)         │
│   ├────────────────────────────────────────────────────┤       │    └─> O(n*d) data copy to Vec<Vec<f32>>         │
│   │ Supported Distance Metrics:                        │       │    └─> Validates inputs                           │
│   │ • euclidean(a, b)     √(Σ(a_i - b_i)²)            │       │                                                    │
│   │ • manhattan(a, b)     Σ|a_i - b_i|                │       │ 2. query(queries, k, ef) → (indices, distances)  │
│   │ • cosine(a, b)        1 - (a·b / |a||b|)          │       │    └─> BRUTE-FORCE: O(n) per query               │
│   │ • chebyshev(a, b)     max(|a_i - b_i|)            │       │    └─> Distance computation → sorting → top k    │
│   │ • minkowski(a, b, p)  (Σ|a_i - b_i|^p)^(1/p)     │       │    └─> Pad with -1 & NaN if < k neighbors       │
│   │ • hamming(a, b)       count(a_i ≠ b_i)            │       │                                                    │
│   │                                                    │       │ 3. neighbor_graph() → (indices, distances)        │
│   │ ALL METRICS FULLY TESTED                          │       │    └─> O(n²*d) all-pairs computation             │
│   │ Zero-vector edge cases handled                    │       │    └─> Caches result in neighbor_graph_cache     │
│   │ SIMD optimization opportunity                     │       │                                                    │
│   │                                                    │       │ 4. prepare() → None (no-op, API compat)          │
│   └────────────────────────────────────────────────────┘       │                                                    │
│                                                                 │ 5. update(new_data) → None                       │
│                                                                 │    └─> Extends self.data Vec                     │
│                                                                 │    └─> Invalidates cache                         │
│                                                                 │                                                    │
│                                                                 │ PRIVATE METHOD:                                    │
│                                                                 │                                                    │
│                                                                 │ compute_distance(a, b) → f32                     │
│                                                                 │  └─> Dispatches to metrics.rs functions         │
│                                                                 │      based on self.metric                        │
│                                                                 │                                                    │
│   CURRENT IMPLEMENTATION NOTE:                                 │                                                    │
│   This is BRUTE-FORCE k-NN, not hierarchical HNSW:            │                                                    │
│   ✗ No multi-layer hierarchical graph                         │                                                    │
│   ✗ No logarithmic search (O(log n))                          │                                                    │
│   ✓ Correct results guaranteed                                │                                                    │
│   ✓ Simple to understand and optimize                         │                                                    │
│   ✓ Foundation for Phase 2 HNSW implementation               │                                                    │
│                                                                 │                                                    │
│   UNUSED IMPORTS (for Phase 2+):                              │                                                    │
│   • Arc<Mutex<T>> - for thread-safe graph                     │                                                    │
│   • rayon::prelude - for parallel distance computation        │                                                    │
│   • serde/serde_json - for index serialization                │                                                    │
│   • parking_lot - for better synchronization                  │                                                    │
│                                                                 └────────────────────────────────────────────────────┘
│
│   ┌────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│   │ COMPILATION PIPELINE                                                                                   │
│   ├────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│   │ Build Tool: Maturin (Rust → Python extension wrapper)                                                 │
│   │ Cargo.toml:                                                                                           │
│   │   [package] name = "_hnsw_backend", version = "0.1.0", edition = "2021", rust-version = "1.74"      │
│   │   [lib] crate-type = ["cdylib"]  # Compiled dynamic library for Python                               │
│   │   [profile.release] opt-level = 3, lto = "fat", codegen-units = 1, strip = true                     │
│   │ Output: lib_hnsw_backend.so (~1-2MB after stripping)                                                 │
│   │ Python Config:                                                                                        │
│   │   [tool.maturin]                                                                                      │
│   │     features = ["pyo3/extension-module"]                                                              │
│   │     python-source = "umap"                                                                            │
│   │     module-name = "umap._hnsw_backend"                                                                │
│   └────────────────────────────────────────────────────────────────────────────────────────────────────────┘
│
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

╔═════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                           DATA FLOW DIAGRAM                                                          ║
╚═════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

INPUT DATA (Python NumPy):
  X: ndarray[n_samples, n_features], dtype=float32
  queries: ndarray[n_queries, n_features], dtype=float32
          │
          │ (automatic conversion to float32 if needed)
          │
          ▼
PYTHON WRAPPER LAYER (hnsw_wrapper.py):
  HnswIndexWrapper.__init__()
  └─> Receives data as PyArray
      Convert to Vec<Vec<f32>> via PyO3 array interop
          │
          ▼
RUST LAYER (hnsw_index.rs):
  HnswIndex::new(data, n_neighbors, metric, m, ef_construction)
  └─> data_slice = data.as_slice()?
      for i in 0..n_samples:
          data_vec.push(data_slice[i*n_features..(i+1)*n_features].to_vec())

  Storage: Vec<Vec<f32>> = [[x1_f1, x1_f2, ...], [x2_f1, x2_f2, ...], ...]
           └─> Indexed in row-major order
           │
           ├─> data[0] = first data point (n_features floats)
           ├─> data[1] = second data point
           └─> ... n_samples total vectors
          │
          ▼
QUERY PROCESSING (hnsw_index.rs::query):
  1. Convert queries ndarray to Vec<Vec<f32>>
  2. FOR EACH query_vec IN queries_vec:
       a. FOR EACH data_vec IN self.data:
            distance = compute_distance(query_vec, data_vec)  // O(d) operation
            neighbors.push((index, distance))
          │ Total: n distances computed, O(n*d)
          │
       b. neighbors.sort_by(|a, b| a.1.partial_cmp(&b.1))  // O(n log n)
          │ Sorted ascending by distance
          │
       c. Extract top k neighbors
          Pad with -1 and NaN if fewer than k

  3. Collect all results:
     all_indices: Vec<Vec<i64>>  [n_queries x k]
     all_distances: Vec<Vec<f32>> [n_queries x k]
          │
          ▼
OUTPUT (Back to Python):
  PyArray2::from_vec2(py, &all_indices)?  → ndarray[n_queries, k], dtype=int64
  PyArray2::from_vec2(py, &all_distances)? → ndarray[n_queries, k], dtype=float32
          │
          ▼
PYTHON WRAPPER LAYER:
  return (indices_array, distances_array)
  └─> Back to HnswIndexWrapper.query() caller
      Continues with UMAP graph construction

╔═════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                      COMPLEXITY ANALYSIS                                                            ║
╚═════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

Operation                          Time Complexity      Space Complexity    Bottleneck
────────────────────────────────────────────────────────────────────────────────────────────
Index Construction                 O(n × d)             O(n × d)            Data copy
Single Query (1 point)             O(n × d)             O(n)                 Distance computation
K Queries (batch)                  O(n × d × k)         O(n + k)             Distance computation × batch
Neighbor Graph (all pairs)         O(n² × d)            O(n² + n×k)          Distance computation (bottleneck)
Update (add m points)              O(m × d)             O(m × d)             Data copy
                                   ↑ sequential

OPTIMIZATION OPPORTUNITIES (Phase 2+):
────────────────────────────────────────────────────────────────────────────────────────────
Parallel Queries:        rayon par_iter()        → 4-8x on 8 cores
SIMD Distance Metrics:   ndarray BLAS            → 2-4x on SSE/AVX
Cosine Preprocessing:    Normalize once          → 2x speedup
Partial Sort:            quickselect vs sort     → 1.5-2x for large k
True HNSW:              Hierarchical graph      → 10-100x for large n
GPU Acceleration:        CUDA batch distances    → 10-100x for large batches

╔═════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                    BACKEND SELECTION LOGIC                                                          ║
╚═════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

User calls: UMAP(metric='cosine', use_pynndescent=None)
            │
            ▼
    umap_.nearest_neighbors()
            │
            ├─ use_hnsw_backend = not use_pynndescent (None → None)
            │
            ├─ NNBackend = _get_nn_backend(metric='cosine', sparse_data=False, use_hnsw=None)
            │
            ▼  DECISION TREE:
    ┌─────────────────────────────────────┐
    │ 1. Is use_hnsw explicitly False?    │─────→ YES ──→ return NNDescent
    └──────┬──────────────────────────────┘
           │ NO
           ▼
    ┌─────────────────────────────────────┐
    │ 2. Is HNSW_AVAILABLE?               │─────→ NO ──→ return NNDescent (with warning if use_hnsw=True)
    └──────┬──────────────────────────────┘
           │ YES
           ▼
    ┌─────────────────────────────────────┐
    │ 3. Is metric in hnsw_metrics?       │─────→ NO ──→ return NNDescent (with warning if use_hnsw=True)
    │    ('euclidean', 'cosine', etc.)    │
    └──────┬──────────────────────────────┘
           │ YES ('cosine' matches)
           ▼
    ┌─────────────────────────────────────┐
    │ 4. Is sparse_data?                  │─────→ YES ──→ return NNDescent (with warning)
    └──────┬──────────────────────────────┘
           │ NO
           ▼
    ┌─────────────────────────────────────┐
    │ 5. Set use_hnsw = True (default)    │
    └──────┬──────────────────────────────┘
           │
           ▼
    ┌─────────────────────────────────────┐
    │ return HnswIndexWrapper ◄────────────┼─── SELECTED
    └─────────────────────────────────────┘

HNSW_METRICS = {'euclidean', 'l2', 'manhattan', 'l1', 'taxicab', 'cosine', 'chebyshev', 'linfinity', 'hamming'}

Unsupported Metrics (fallback to PyNNDescent):
  'minkowski', 'correlation', 'seuclidean', 'squaredeuclidean', 'braycurtis', 'canberra',
  'chebyshev', 'cityblock', 'cosine', 'correlation', 'dice', 'euclidean', 'hamming',
  'jaccard', 'jensenshannon', 'kulsinski', 'mahalanobis', 'matching', 'minkowski',
  'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath',
  'sqeuclidean', 'yule', and custom callable metrics

Sparse Data:
  scipy.sparse matrices → automatically use PyNNDescent (sparse support not yet in HNSW)
